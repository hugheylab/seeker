checkSeekerArrayArgs = function(params, parentDir) {
  assertList(params)
  assertSetEqual(names(params), c('study', 'geneIdType'))
  assertString(params$study, min.chars = 1L)
  assertChoice(params$geneIdType, c('ensembl', 'entrez'))
  assertString(parentDir)
  assertDirectoryExists(parentDir)
  outputDir = file.path(path.expand(parentDir), params$study) # untar no like ~
  return(outputDir)}


#' Process microarray data end to end
#'
#' This function fetches data and metadata from NCBI GEO and ArrayExpress,
#' processes raw Affymetrix data using RMA and custom CDFs from Brainarray, and
#' maps probes to genes.
#'
#' The standard output:
#' * naive_expression_set.qs: Initial `ExpresssionSet` generated by
#'   [GEOquery::getGEO] or [ArrayExpress::ae2bioc()]. Should generally *not* be
#'   used if sample_metadata.csv and gene_expression_matrix.qs are available.
#' * sample_metadata.csv: Table of sample metadata. Column `sample_id` matches
#'   colnames of the gene expression matrix.
#' * gene_expression_matrix.qs: Rows correspond to genes, columns to samples.
#' * custom_cdf_name.txt: Name of custom CDF package used by [affy::justRMA()]
#'   to process and normalize raw Affymetrix data and map probes to genes.
#' * feature_metadata.qs: `GPL` object, if gene expression matrix was generated
#'   from processed data.
#' * probe_gene_mapping.csv.gz: Table of probes and genes, if gene expression
#'   matrix was generated from processed data.
#' * "raw" directory: Contains raw Affymetrix files.
#' * params.yml: Parameters used to process the dataset.
#' * session.log: Detailed R session information.
#'
#' The output may include other files from NCBI GEO or ArrayExpress. Files with
#' extension "qs" can be read into R using [qs::qread()].
#'
#' @param params Named list of parameters with components:
#' * `study`: String indicating the study accession and used to name the output
#'   directory within `parentDir`. If `study` starts with 'GSE', data are
#'   fetched using [GEOquery::getGEO()]. Otherwise the data are fetched
#'   using [ArrayExpress::getAE()].
#' * `geneIdType`: String indicating whether to map probes to gene IDs from
#'   Ensembl ('ensembl') or Entrez ('entrez').
#'
#' `params` can be derived from a yaml file, see
#' \code{vignette('introduction', package = 'seeker')}. The yaml representation
#' of `params` will be saved to `parentDir`/`params$study`/params.yml.
#' @param parentDir Directory in which to store the output, which will be a
#'   directory named according to `params$study`.
#'
#' @return `NULL`, invisibly.
#'
#' @export
seekerArray = function(params, parentDir) {
  outputDir = checkSeekerArrayArgs(params, parentDir)
  if (!dir.exists(outputDir)) dir.create(outputDir)
  rawDir = file.path(outputDir, 'raw')

  withr::local_options(timeout = 600)
  withr::local_envvar(VROOM_CONNECTION_SIZE = 131072 * 20)

  repo = if (startsWith(params$study, 'GSE')) 'geo' else 'ae'

  result = if (repo == 'geo') {
    getNaiveEsetGeo(params$study, outputDir, rawDir)
  } else {
    getNaiveEsetAe(params$study, outputDir, rawDir)}

  if (is.character(result)) {
    warning(result)
    return(invisible())}
  eset = result[[1L]]
  rmaOk = result[[2L]]

  qs::qsave(eset, file.path(outputDir, 'naive_expression_set.qs'))

  sampColname = 'sample_id'
  metadata = data.table(eset@phenoData@data, keep.rownames = sampColname)
  set(metadata, j = sampColname, value = stripFileExt(metadata[[sampColname]]))
  fwrite(metadata, file.path(outputDir, 'sample_metadata.csv'))

  if (rmaOk) {
    cdfname = getCdfname(eset@annotation, params$geneIdType)
    if (length(cdfname) == 0) {
      warning(glue(
        '{params$study} uses platform {eset@annotation}, which is ',
        'unsupported for mapping probes to genes using raw data.'))
      return(invisible())}

    if (!requireNamespace(cdfname, quietly = TRUE)) {
      installCustomCdfPackages(cdfname)}
    fwrite(list(cdfname), file.path(outputDir, 'custom_cdf_name.txt'))

    emat = seekerRma(rawDir, cdfname)
    colnames(emat) = getNewEmatColnames(colnames(emat), repo)
    emat = emat[, metadata[[sampColname]]]

    paths = dir(rawDir, '\\.cel$', full.names = TRUE, ignore.case = TRUE)
    for (path in paths) {
      R.utils::gzip(path, overwrite = TRUE)}

  } else {
    # this is only datasets from GEO
    featureMetadata = GEOquery::getGEO(eset@annotation)
    qs::qsave(featureMetadata, file.path(outputDir, 'feature_metadata.qs'))
    featureDt = setDT(featureMetadata@dataTable@table)

    platforms = getPlatforms('mapping')
    platformDt = platforms[platforms$platform == eset@annotation]

    if (nrow(platformDt) == 0) {
      warning(glue(
        '{params$study} uses platform {eset@annotation}, which is ',
        'unsupported for mapping probes to genes using processed data.'))
      return(invisible())}

    mapping = getProbeGeneMapping(featureDt, platformDt, params$geneIdType)
    fwrite(mapping, file.path(outputDir, 'probe_gene_mapping.csv.gz'))
    emat = getEmatGene(eset@assayData$exprs, mapping)}

  qs::qsave(emat, file.path(outputDir, 'gene_expression_matrix.qs'))
  yaml::write_yaml(params, file.path(outputDir, 'params.yml'))
  sessioninfo::session_info(
    info = c('platform', 'packages'),
    to_file = file.path(outputDir, 'session.log'))

  invisible()}
